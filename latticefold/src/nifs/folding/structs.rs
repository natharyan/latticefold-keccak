use ark_serialize::{CanonicalDeserialize, CanonicalSerialize};
use ark_std::marker::PhantomData;
use cyclotomic_rings::rings::SuitableRing;
use stark_rings::OverField;
use stark_rings_poly::mle::DenseMultilinearExtension;

use crate::{
    arith::{Witness, CCS, LCCCS},
    ark_base::Vec,
    decomposition_parameters::DecompositionParams,
    nifs::error::FoldingError,
    transcript::TranscriptWithShortChallenges,
    utils::sumcheck,
};

/// Proof generated by the folding prover.
#[derive(Clone, Debug, PartialEq, CanonicalSerialize, CanonicalDeserialize)]
pub struct FoldingProof<NTT: OverField> {
    /// A list of non-interactive sumcheck prover messages.  
    ///
    /// Sent in step 2 of folding subprotocol.
    pub pointshift_sumcheck_proof: sumcheck::Proof<NTT>,
    /// The evaluations of MLEs of the rows of $\hat{\mathbf{f}}$-matrices of the witness at the $\overrightarrow{r}_0$ challenge point, i.e.
    ///
    /// $$
    /// \theta[i]= \text{mle}[\text{wit.f\\_hat[i]}] (\overrightarrow{r}_0).
    /// $$
    ///
    /// Sent in the step 3 of folding subprotocol.
    pub theta_s: Vec<Vec<NTT>>,
    /// The evaluations of MLE's of $\\{ M_j \mathbf{z}_i \mid j = 1, 2, \dots, t, i = 1, 2 \dots 2k \\}$ at evaluated at the $\overrightarrow{r}_0$ challenge point, i.e.
    ///
    /// $$
    /// \eta[j][i] =  \sum\_{\vec{\mathbf{b}} \in \\{0,1\\}^{\log n\_c}}
    /// \text{mle}[\text{ccs.M[j]}](\vec{\mathbf{x}}, \vec{\mathbf{b}}) \cdot \text{mle}\[\mathbf{z}_{i}\](\vec{\mathbf{b}}).
    /// $$
    ///
    /// Sent in the step 3 of folding subprotocol.
    pub eta_s: Vec<Vec<NTT>>,
}

/// Prover for the folding subprotocol
pub trait FoldingProver<NTT: SuitableRing, T: TranscriptWithShortChallenges<NTT>> {
    /// Generates a folded witness and its linearized commitment, along with proof to the correctness of the folding.
    ///
    /// # Arguments
    ///
    /// * `cm_i_s` - A reference to `[LCCCS<C, NTT>]`, representing decomposed linearized commitments to be folded together.
    /// * `w_s` - A vector of decomposed witnesses to be folded together.
    /// * `transcript` - A mutable reference to a sponge for generating NI challenges.
    /// * `ccs` -  A reference to a Customizable Constraint System instance used in the protocol.
    /// # Returns
    ///
    /// On success, returns a tuple `(LCCCS<C, NTT>, Witness<NTT>, FoldingProof<NTT>)` where:
    ///   * `LCCCS<C, NTT>` is a folded linearized version of the CCS witness commitment.
    ///   * `Witness<NTT>` is a folded CCS and Ajtai witness.
    ///   * `LinearizationProof<NTT>` is a proof that the linearization subprotocol was executed correctly.
    ///
    /// # Errors
    ///
    /// Returns an error if asked to evaluate MLEs with incorrect number of variables
    ///
    fn prove<const C: usize, P: DecompositionParams>(
        cm_i_s: &[LCCCS<C, NTT>],
        w_s: Vec<Witness<NTT>>,
        transcript: &mut impl TranscriptWithShortChallenges<NTT>,
        ccs: &CCS<NTT>,
        mz_mles: &[Vec<DenseMultilinearExtension<NTT>>],
    ) -> Result<(LCCCS<C, NTT>, Witness<NTT>, FoldingProof<NTT>), FoldingError<NTT>>;
}

/// Verifier for folding subprotocol
pub trait FoldingVerifier<NTT: SuitableRing, T: TranscriptWithShortChallenges<NTT>> {
    /// Verifies a proof for the folding subprotocol.
    ///
    /// # Arguments
    ///
    /// * `cm_i` - A reference to a vector of `CCCS<C, NTT>`, which represents decomposed LCCS statements and commitments to witnesses.
    /// * `proof` - A reference to a `FoldingProof<NTT>` containing the folding proof.
    /// * `transcript` - A mutable reference to a sponge for generating NI challenges.
    /// * `ccs` - A reference to a Customizable Constraint System instance used in the protocol.
    ///
    /// # Returns
    ///
    /// * `Ok(LCCCS<C, NTT>)` - On success, returns the folded linearized version of the CCS witness commitment.
    /// * `Err(FoldingError<NTT>)` - If verification fails, returns a `FoldingError<NTT>`.
    ///
    fn verify<const C: usize, P: DecompositionParams>(
        cm_i_s: &[LCCCS<C, NTT>],
        proof: &FoldingProof<NTT>,
        transcript: &mut impl TranscriptWithShortChallenges<NTT>,
        ccs: &CCS<NTT>,
    ) -> Result<LCCCS<C, NTT>, FoldingError<NTT>>;
}

/// The LatticeFold folding prover
///
/// Implements the [`FoldingProver`] trait.
pub struct LFFoldingProver<NTT, T> {
    _ntt: PhantomData<NTT>,
    _t: PhantomData<T>,
}

/// The LatticeFold folding verifier
///
/// Implements the [`FoldingVerifier`] trait.
pub struct LFFoldingVerifier<NTT, T> {
    _ntt: PhantomData<NTT>,
    _t: PhantomData<T>,
}
