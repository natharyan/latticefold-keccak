use ark_std::{fmt::Display, marker::PhantomData};
use lattirust_poly::polynomials::{ArithErrors, VPAuxInfo, VirtualPolynomial};
use lattirust_ring::{OverField, Ring};
use thiserror::Error;

use crate::transcript::Transcript;
use prover::{ProverMsg, ProverState};
use verifier::SubClaim;

pub mod prover;
pub mod verifier;

/// Interactive Proof for Multilinear Sumcheck
pub struct IPForMLSumcheck<R, T> {
    #[doc(hidden)]
    _marker: PhantomData<(R, T)>,
}

#[derive(Error, Debug)]
pub enum SumCheckError<R: Ring + Display> {
    #[error("univariate polynomial evaluation error")]
    EvaluationError(ArithErrors),
    #[error("incorrect sumcheck sum. Expected `{0}`. Received `{1}`")]
    SumCheckFailed(R, R),
    #[error("max degree exceeded")]
    MaxDegreeExceeded,
}

impl<R: Ring> From<ArithErrors> for SumCheckError<R> {
    fn from(arith_error: ArithErrors) -> Self {
        Self::EvaluationError(arith_error)
    }
}

/// Sumcheck for products of multilinear polynomial
pub struct MLSumcheck<R, T>(#[doc(hidden)] PhantomData<(R, T)>);

/// proof generated by prover
pub type Proof<R> = Vec<ProverMsg<R>>;

impl<R: OverField, T: Transcript<R>> MLSumcheck<R, T> {
    /// extract sum from the proof
    pub fn extract_sum(proof: &Proof<R>) -> R {
        proof[0].evaluations[0] + proof[0].evaluations[1]
    }

    /// This function does the same thing as `prove`, but it uses cryptographic sponge as the transcript/to generate the
    /// verifier challenges. Additionally, it returns the prover's state in addition to the proof.
    /// Both of these allow this sumcheck to be better used as a part of a larger protocol.
    pub fn prove_as_subprotocol(
        transcript: &mut T,
        polynomial: &VirtualPolynomial<R>,
    ) -> (Proof<R>, ProverState<R>) {
        // TODO: return this back
        // transcript.absorb(&polynomial.info());

        let mut prover_state = IPForMLSumcheck::<R, T>::prover_init(polynomial);
        let mut verifier_msg = None;
        let mut prover_msgs = Vec::with_capacity(polynomial.aux_info.num_variables);
        for _ in 0..polynomial.aux_info.num_variables {
            let prover_msg = IPForMLSumcheck::<R, T>::prove_round(&mut prover_state, &verifier_msg);
            transcript.absorb_slice(&prover_msg.evaluations);
            prover_msgs.push(prover_msg);
            let next_verifier_msg = IPForMLSumcheck::<R, T>::sample_round(transcript);
            transcript.absorb(&next_verifier_msg.randomness.into());

            verifier_msg = Some(next_verifier_msg);
        }
        prover_state
            .randomness
            .push(verifier_msg.unwrap().randomness);

        (prover_msgs, prover_state)
    }

    /// This function does the same thing as `prove`, but it uses a cryptographic sponge as the transcript/to generate the
    /// verifier challenges. This allows this sumcheck to be used as a part of a larger protocol.
    pub fn verify_as_subprotocol(
        transcript: &mut T,
        polynomial_info: &VPAuxInfo<R>,
        claimed_sum: R,
        proof: &Proof<R>,
    ) -> Result<SubClaim<R>, SumCheckError<R>> {
        // TODO: bring this back
        //transcript.absorb(polynomial_info);

        let mut verifier_state = IPForMLSumcheck::<R, T>::verifier_init(polynomial_info);
        for i in 0..polynomial_info.num_variables {
            let prover_msg = proof.get(i).expect("proof is incomplete");
            transcript.absorb_slice(&prover_msg.evaluations);
            let verifier_msg = IPForMLSumcheck::verify_round(
                (*prover_msg).clone(),
                &mut verifier_state,
                transcript,
            );
            transcript.absorb(&verifier_msg.randomness.into());
        }

        IPForMLSumcheck::<R, T>::check_and_generate_subclaim(verifier_state, claimed_sum)
    }
}

#[macro_export]
macro_rules! generate_sumcheck_tests {
    () => {
        use ark_ff::Zero;
        use $crate::{transcript::poseidon::PoseidonTranscript, utils::sumcheck::MLSumcheck};

        use lattirust_poly::polynomials::VirtualPolynomial;
        #[test]
        fn test_sumcheck() {
            let mut rng = ark_std::test_rng();

            for _ in 0..20 {
                let mut transcript: PoseidonTranscript<R, CS> = PoseidonTranscript::default();

                let (poly, sum) = VirtualPolynomial::<R>::rand(5, (2, 5), 3, &mut rng).unwrap();

                let (proof, _) = MLSumcheck::prove_as_subprotocol(&mut transcript, &poly);

                let mut transcript: PoseidonTranscript<R, CS> = PoseidonTranscript::default();
                let res =
                    MLSumcheck::verify_as_subprotocol(&mut transcript, &poly.aux_info, sum, &proof);
                assert!(res.is_ok())
            }
        }
        #[test]
        fn test_failing_sumcheck() {
            let mut rng = ark_std::test_rng();

            for _ in 0..20 {
                let mut transcript: PoseidonTranscript<R, CS> = PoseidonTranscript::default();

                let (poly, _) = VirtualPolynomial::<R>::rand(5, (2, 5), 3, &mut rng).unwrap();
                let (proof, _) = MLSumcheck::prove_as_subprotocol(&mut transcript, &poly);

                let not_sum = poly
                    .evaluate(&[R::zero(), R::zero(), R::zero(), R::zero(), R::zero()])
                    .unwrap();

                let res = MLSumcheck::verify_as_subprotocol(
                    &mut transcript,
                    &poly.aux_info,
                    not_sum,
                    &proof,
                );
                assert!(res.is_err());
            }
        }
    };
}
#[cfg(test)]
mod tests_pow2 {

    use lattirust_ring::cyclotomic_ring::models::pow2_debug::Pow2CyclotomicPolyRingNTT;

    use cyclotomic_rings::challenge_set::BinarySmallSet;
    const Q: u64 = 17;
    const N: usize = 8;
    type R = Pow2CyclotomicPolyRingNTT<Q, N>;

    type CS = BinarySmallSet<Q, N>;

    generate_sumcheck_tests!();
}

#[cfg(test)]
mod tests_stark {

    use cyclotomic_rings::rings::StarkChallengeSet;
    use lattirust_ring::cyclotomic_ring::models::stark_prime::RqNTT;
    type R = RqNTT;

    type CS = StarkChallengeSet;

    generate_sumcheck_tests!();
}

#[cfg(test)]
mod tests_frog {

    use cyclotomic_rings::rings::FrogChallengeSet;

    use lattirust_ring::cyclotomic_ring::models::frog_ring::RqNTT;

    type R = RqNTT;

    type CS = FrogChallengeSet;

    generate_sumcheck_tests!();
}

#[cfg(test)]
mod tests_goldilocks {

    use cyclotomic_rings::rings::GoldilocksChallengeSet;

    use lattirust_ring::cyclotomic_ring::models::goldilocks::RqNTT;

    type R = RqNTT;

    type CS = GoldilocksChallengeSet;

    generate_sumcheck_tests!();
}

#[cfg(test)]
mod tests_babybear {

    use lattirust_ring::cyclotomic_ring::models::babybear::RqNTT;

    use cyclotomic_rings::rings::BabyBearChallengeSet;

    type R = RqNTT;

    type CS = BabyBearChallengeSet;

    generate_sumcheck_tests!();
}
